# AGENTS – E2E Testing with Playwright

This document defines **E2E test writing rules** for AI agents using **Playwright Test** in a **Next.js (App Router)** web application.

Core Goals:

1. Create stable E2E tests based on human-written **TODO scenario documents** (natural language).
2. Leverage **Playwright Test Agents** standard flow: planner → generator → healer for **test plan → test code → self-healing on failure** loops.
3. Tests always prioritize the **user's perspective (user journey)**. Avoid unnecessary dependencies on implementation details (internal functions, DB structure, etc.).

---

## 1. Environment & Directory Conventions

### 1.1 Tech Stack

- Framework: **Next.js (App Router)**
- Test Runner: `@playwright/test`
- Playwright Test Agents: **planner / generator / healer**
- Language: TypeScript
- Browsers: Chromium, Firefox, WebKit (run all three simultaneously)
- MCP: `@playwright/mcp` (browser control from IDE/agents)

### 1.2 Directory Structure

> If the repo already has a Playwright Agents structure, follow that first.
> (e.g., structure generated by `npx playwright init-agents --loop=claude`)

Default structure (example):

```txt
repo/
  .github/
    agents/                  # Agent definitions from init-agents (planner/generator/healer)
  specs/                     # Official test plans generated by planner
    basic-operations.md
  e2e/
    specs/                   # Human-written TODO scenario documents
      posts/
        post-detail.todo.md
        post-like.todo.md
      home/
        home.todo.md
    tests/                   # Actual Playwright test code
      posts/
        post-like-guest.spec.ts
        post-like-member.spec.ts
      home/
        home-guest.spec.ts
    fixtures/
      auth.fixtures.ts
    page-objects/
      post-list.page.ts
      post-detail.page.ts
  tests/                     # (Coexists if default Playwright tests dir exists)
    seed.spec.ts             # Seed test (used by planner/generator)
  playwright.config.ts
```

- **Playwright Agents standard**:
  - planner: Generates Markdown test plans in `specs/*.md`
  - generator: Creates `tests/*.spec.ts` (or subdirectories per config)

- **Project-specific rules**:
  - Human-written TODO docs: `e2e/specs/{feature}/**.todo.md`
  - Final E2E test code: `e2e/tests/{feature}/**.spec.ts`
  - **specs and tests maintain identical folder structure** (e.g., `e2e/specs/posts/` ↔ `e2e/tests/posts/`)

---

## 2. TODO Document-Based Workflow

### 2.1 Human-Written TODO Document Format

TODO documents are written per **page** or per **feature**.

Example: `e2e/specs/post-detail.todo.md`

```md
# /posts/[id] Detail Page - Like

[Scenario 1] Guest clicks like on the first post

1. Access /posts page as a guest.
2. Click the first post card to navigate to detail page.
3. Click the like button (heart icon).
4. Login prompt modal appears with "Login required" message.

[Scenario 2] Member clicks like on the first post

1. Access /posts page logged in with test account.
2. Click the first post card to navigate to detail page.
3. Click like button, like count increases by +1.
4. After refresh, like state and count persist.
```

Rules:
- `[Scenario N]` describes **one user journey** per unit.
- Each step can naturally mix "user action" and "expected result".
- For data dependencies like "first post", write based on fixed data that always exists.

### 2.2 Relationship Between Agents and TODO Documents

Agents use TODO documents as follows:

- **planner**
  - References `e2e/specs/*.todo.md` and the actual app together.
  - Generates/refines Markdown test plans (`specs/*.md`) in Playwright standard format.
  - **Don't overwrite** human-written TODO content; organize scenarios more structurally (sections/Expected results separation).

- **generator**
  - Based on `specs/*.md` (planner output), creates `e2e/tests/**.spec.ts` files.

- **healer**
  - Re-runs and analyzes failed `e2e/tests/**.spec.ts`.
  - Fixes locator/timing/data issues to recover tests.

---

## 3. Planner Agent Rules

### 3.1 Input

- Natural language request: e.g., `"Create a plan for guest/member like flow"`
- Required: **seed test** file (e.g., `tests/seed.spec.ts`)
- Optional:
  - Related TODO document (`e2e/specs/post-detail.todo.md`)
  - Related PRD / design documents

### 3.2 Operation Rules

1. **Run seed test**
   - Follow Playwright's seed test structure.
   - In this project, seed test typically defines "basic Next.js app + common fixture setup".

   ```ts
   // tests/seed.spec.ts
   import { test, expect } from './fixtures';

   test('seed', async ({ page }) => {
     // Only verify that common fixtures / global setup work
   });
   ```

2. **App exploration + TODO document merge**
   - Run app based on seed test, **actually explore the browser** to understand DOM structure.
   - Based on TODO document scenarios:
     - Explicitly separate steps and expected results in the test plan.

3. **Write Markdown test plan**

Output location: `specs/{feature-name}.md`

Structure example:

```md
# /posts List & Detail Page - Like Test Plan

## 1. Guest Like Flow

**Seed:** `tests/seed.spec.ts`
**Source TODO:** `e2e/specs/post-detail.todo.md` [Scenario 1]

### Steps

1. Access `/posts` page as guest.
2. Click first post card to navigate to detail page.
3. Click like button (heart icon).

### Expected Results

- Login prompt modal appears.
- Modal contains text `"Login required"`.
- Like count / state does not change.
```

4. **Cautions**
   - Planner **does not generate test code directly**.
   - Don't hardcode locators assuming you know the app structure; express only **"what to verify"** in Markdown.
   - Can add new scenarios not in TODO document, but mark with `Origin: planner-suggested`.

---

## 4. Generator Agent Rules

### 4.1 Input

- `specs/*.md` (Markdown plan from planner)
- seed test (`tests/seed.spec.ts`)
- `playwright.config.ts` from this repo

### 4.2 Output

- Playwright TypeScript test code
- Location: `e2e/tests/**.spec.ts`

Example: `specs/basic-operations.md` → `e2e/tests/posts/post-like-guest.spec.ts`

### 4.3 Code Writing Rules

#### 4.3.1 Basic Structure

```ts
// spec: specs/post-like.md
// seed: tests/seed.spec.ts

import { test, expect } from '../../fixtures/auth.fixtures';

test.describe('/posts/[id] - Like', () => {
  test('Guest clicking like shows login modal', async ({ page }) => {
    // ...
  });

  test('Member clicking like increases count', async ({ memberPage }) => {
    // ...
  });
});
```

- Filename combines **feature + scenario**:
  - `/posts/[id]` like → `post-like-guest.spec.ts`, `post-like-member.spec.ts`, etc.
- Test names use TODO document scenario descriptions, slightly refined for clarity.

#### 4.3.2 Next.js & Navigation

- **Never hardcode route addresses**. Always import from constants file.

```ts
import { ROUTES } from '@/constants/routes';

if (!ROUTES.POSTS) {
  throw new Error('ROUTES.POSTS is not defined in constants. Check constants file.');
}

await page.goto(ROUTES.POSTS);
```

- If route is not in constants:
  - Don't run the test; notify the user.
  - Example error message: `"ROUTES.POSTS is not defined in constants. Check constants file."`
- Use `playwright.config.ts`'s `use.baseURL` as much as possible.
- After page transitions:
  - `await page.waitForLoadState('networkidle')` **OR**
  - Specific key element visibility assertion (`await expect(...).toBeVisible()`)
  - Then proceed with remaining verifications.
- **Prohibited**: `waitForTimeout` (causes flakiness).

#### 4.3.3 Screenshot / Video / Trace

- Set auto-capture on failure in `playwright.config.ts`:

```ts
export default defineConfig({
  use: {
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    trace: 'retain-on-failure',
  },
});
```

- Use Trace Viewer for debugging:

```bash
npx playwright test --trace on
npx playwright show-report
```

#### 4.3.4 Locator Strategy

> Follow official guide and MCP/Agents best practices.

Priority:
1. `page.getByTestId(...)` — Top priority. Most stable and explicit.
2. `page.getByRole(...)` — Also serves accessibility verification.
3. `page.getByLabel(...)` — For form controls.
4. `page.getByText(...)` — For non-interactive elements.
5. CSS/XPath locator (`page.locator`) — Last resort.

Examples:

```ts
const firstPostCard = page.getByTestId('post-card').first();
const likeButton = page.getByRole('button', { name: /like/i });
const loginModal = page.getByRole('dialog', { name: /login required/i });
```

List + filter:

```ts
const postItem = page
  .getByRole('article')
  .filter({ hasText: 'First post title' });
```

#### 4.3.5 Assertions

- Use **only web-first assertions** (`await expect(...)`).

```ts
await expect(page.getByText('Login required')).toBeVisible();
await expect(likeButton).toBeEnabled();
```

- **Prohibited**: `.isVisible()` followed by synchronous `expect`.
- For multiple verifications:
  - Main results: hard assertions
  - Less important UI messages: `expect.soft` acceptable.

#### 4.3.6 Login / Permissions

- **Prioritize reusing existing fixtures/helpers** (e.g., `auth.fixtures.ts`).
- If none exist, create with reusable naming.

```ts
// e2e/fixtures/auth.fixtures.ts
import { test as base } from '@playwright/test';
import { ROUTES } from '@/constants/routes';

export const test = base.extend<{
  memberPage: typeof base['page'];
}>({
  memberPage: async ({ page }, use) => {
    if (!ROUTES.LOGIN) {
      throw new Error('ROUTES.LOGIN is not defined in constants.');
    }
    await page.goto(ROUTES.LOGIN);
    await page.getByLabel('Email').fill(process.env.E2E_USER_EMAIL!);
    await page.getByLabel('Password').fill(process.env.E2E_USER_PASSWORD!);
    await page.getByRole('button', { name: /login/i }).click();
    if (!ROUTES.HOME) {
      throw new Error('ROUTES.HOME is not defined in constants.');
    }
    await page.waitForURL(ROUTES.HOME);
    await use(page);
  },
});
```

#### 4.3.7 Functional Page Object Model (POM)

> **Reference**: Inspired by [Toss Income E2E Automation Journey](https://toss.tech/article/income-qa-e2e-automation).

**Core Principle**: Use **Functional (Stateless) POM** instead of class-based POM.

- **Design page behaviors as stateless functions instead of stateful classes.**
- Principle: Take `page` (and `context` if needed) as input, return `page` as output.
- This avoids `this` state management and inheritance complexity, reducing maintenance cost.

**Before — Test without POM (duplicated, fragile)**

```ts
// ❌ This code was copied across multiple files
async function test1() {
  await page.goto(ROUTES.POSTS);
  await page.click('#category-selector');
  await page.click('button:has-text("All")');
  await page.click('button:has-text("Write")'); // Text change breaks all files
  await page.fill('[placeholder="Enter title"]', 'Test title');
  // ...
}
```

**After — Encapsulated with Functional POM**

```ts
// e2e/page-objects/post-list.page.ts
import { Page, BrowserContext } from '@playwright/test';
import { ROUTES } from '@/constants/routes';

/**
 * Navigate to post list page and prepare initial state.
 */
export async function gotoPostListPage(
  page: Page,
  context?: BrowserContext
): Promise<Page> {
  if (!ROUTES.POSTS) {
    throw new Error('ROUTES.POSTS is not defined in constants.');
  }
  await page.goto(ROUTES.POSTS);
  await waitForNetworkIdleSafely(page);
  return page;
}

/**
 * Click category selection button.
 */
export async function clickCategoryButton(
  page: Page,
  categoryName: string
): Promise<Page> {
  await clickButton(page, categoryName);
  await waitForNetworkIdleSafely(page);
  return page;
}

/**
 * Click write button.
 * If text changes, modify only here.
 */
export async function clickWriteButton(page: Page): Promise<Page> {
  await clickButton(page, 'Write');
  await waitForNetworkIdleSafely(page);
  return page;
}
```

**Tests read like user scenarios**

```ts
// e2e/tests/posts/post-write.spec.ts
import { test, expect } from '../../fixtures/auth.fixtures';
import {
  gotoPostListPage,
  clickCategoryButton,
  clickWriteButton,
} from '../../page-objects/post-list.page';

test('Member can write a post', async ({ memberPage }) => {
  let currentPage = await gotoPostListPage(memberPage);
  currentPage = await clickCategoryButton(currentPage, 'All');
  currentPage = await clickWriteButton(currentPage);
  // ...
});
```

**Naming Conventions (for readability)**

| Prefix             | Meaning       | Example                             |
| ------------------ | ------------- | ----------------------------------- |
| `goto`             | Navigate      | `gotoPostListPage()`                |
| `click`            | Click         | `clickLikeButton()`                 |
| `enter`            | Input         | `enterPostTitle()`                  |
| `answer`           | Respond       | `answerConfirmDialog()`             |
| `add`/`skip`/`update` | Data manipulation | `addComment()`, `skipOptionalStep()` |
| `verify`/`check`   | Verify        | `verifyPostCount()`                 |
| `waitFor`          | Wait          | `waitForPostListReady()`            |
| `complete`         | Complex flow  | `completeLogin()`                   |

**Split files by user scenario, not by screen**

Example: Split post creation flow by steps

```
e2e/page-objects/
├── post-list.page.ts        # List page (view, filter)
├── post-write.page.ts       # Write page (title, content input)
├── post-detail.page.ts      # Detail page (view, like, comment)
└── post-edit.page.ts        # Edit page (edit, save)
```

**Robust Click Strategy — Resilient to click failures**

Add 4-step fallback to click utils to reduce flakiness from React rendering timing:

```ts
// e2e/utils/click.utils.ts
import { Page } from '@playwright/test';

/**
 * Reliably click a button with 4-step fallback strategy.
 */
export async function clickButton(
  page: Page,
  buttonName: string,
  options: { role?: 'button' | 'link' } = {}
): Promise<void> {
  const role = options.role || 'button';
  const button = page.getByRole(role, { name: buttonName });
  await button.waitFor({ state: 'visible' });

  try {
    // 1) Enter key (most stable)
    await button.focus();
    await page.keyboard.press('Enter');
  } catch {
    try {
      // 2) Default click
      await button.click();
    } catch {
      try {
        // 3) Force click
        await button.click({ force: true });
      } catch {
        // 4) Direct JS execution
        await page.evaluate(
          ({ name, role }) => {
            const elements = Array.from(
              document.querySelectorAll(`${role}, [role="${role}"]`)
            );
            const btn = elements.find(
              (el) =>
                el.textContent?.includes(name) ||
                el.getAttribute('aria-label') === name
            ) as HTMLElement;
            btn?.click();
          },
          { name: buttonName, role }
        );
      }
    }
  }

  await waitForNetworkIdleSafely(page);
}
```

**Page Transition Detection — Safe across new tabs/redirects**

```ts
// e2e/utils/page.utils.ts
import { BrowserContext, Page } from '@playwright/test';

/**
 * Get the latest valid page from context.
 * Works safely after new tabs or redirects.
 */
export async function getLatestValidPage(
  context: BrowserContext,
  excludeUrls: string[] = []
): Promise<Page> {
  const pages = context.pages();
  for (let i = pages.length - 1; i >= 0; i--) {
    const p = pages[i];
    if (p.isClosed()) continue;

    const url = p.url();
    const shouldExclude = excludeUrls.some((pattern) => url.includes(pattern));
    if (!shouldExclude) return p;
  }
  throw new Error('No valid page found');
}

/**
 * Safely wait for network idle.
 * Continues test even if timeout occurs.
 */
export async function waitForNetworkIdleSafely(
  page: Page,
  timeout: number = 5000
): Promise<void> {
  try {
    await page.waitForLoadState('networkidle', { timeout });
  } catch {
    // Continue even on timeout (network may not fully stop)
  }
}
```

**Writing Readable Tests**

1. **Start with descriptive titles**
   - Write test titles as descriptive sentences.
   - Example: `"Guest clicking like shows login modal"`

2. **Clarify preconditions**
   - Preconditions should have minimal context: "logged-in user", "can access post list".

3. **Write in Given-When-Then structure**
   - Scenarios follow Given-When-Then rhythm.
   - Example: "Given logged in, When click first post and like button, Then count increases."

4. **Transform natural language to code**

```ts
test('Logged-in member clicking like increases count', async ({ memberPage }) => {
  // Given: Access post list page while logged in
  let currentPage = await gotoPostListPage(memberPage);

  // When: Click first post → navigate to detail
  currentPage = await clickFirstPostCard(currentPage);

  // When: Click like button
  const initialCount = await getLikeCount(currentPage);
  await clickLikeButton(currentPage);

  // Then: Verify like count increased by 1
  await expect(currentPage.getByTestId('like-count')).toHaveText(
    String(initialCount + 1)
  );
});
```

The key: **Tests should be readable first, code follows.** This way non-developers can understand tests, and developers get immediately executable scripts.

---

## 5. Healer Agent Rules

### 5.1 Role

- Debug failed Playwright tests and auto-fix when possible.
- Primary fix targets:
  - Changed locators (label name changes, button text changes, etc.)
  - Timing issues (unnecessary `waitForTimeout`, wrong load conditions, etc.)
  - Minor data changes (text copy changes, count value consistency, etc.)

### 5.2 Operation Sequence

1. **Identify failed test**
   - Use `mcp__playwright-test__test_list` / `test_run` etc. to find failed cases.

2. **Re-run & UI investigation**
   - Re-run failure point, use `browser_snapshot`, `browser_console_messages`, `browser_network_requests` to find root cause.

3. **Propose & apply patch**
   - Locator updates, unnecessary wait removal, assertion text fixes, etc.
   - **Modify only test code**.

4. **Re-run and report results**
   - Run test again after fix to verify pass.
   - If the feature itself is broken, don't force the test to "pass".
   - Leave as failed with comment/memo, or convert to `test.skip`.

### 5.3 Prohibited Actions

- **Do not modify actual app code** (Next.js pages/components/backend code).
- **Do not use loose assertions** (e.g., `toBeTruthy`) to force pass.
- **Do not ignore TODO document / PRD requirements** and redefine behavior arbitrarily.

---

## 6. Common Testing Philosophy

> Summary of E2E / Playwright best practices from various sources and Functional POM philosophy from [Toss Income E2E Automation Journey](https://toss.tech/article/income-qa-e2e-automation).

1. **Verify only user-visible behavior.**
   - Don't over-depend on deep DOM structure, internal state, API shapes.

2. **Tests must be independent (Test Isolation).**
   - Each test prepares its own required state (login, seed data).
   - Test isolation **improves reproducibility, eases debugging, prevents cascade failures**.
   - Use `test.beforeEach()` hooks for repetitive pre-test work, or setup projects for login state reuse.

3. **Allow some duplication; abstract to helper/fixture when it gets complex.**

4. **Test name and file name should immediately convey "what is being verified".**

5. **Flake prevention is top priority.**
   - Solve timing issues with web-first assertions/locator strategy.
   - Use Robust Click Strategy (4-step fallback) for click failure resilience.

6. **Agents automate only test code.**
   - Business logic and domain rules always defer to human-defined TODO documents / PRD.

7. **Functional POM: Beat complexity with simplification and consistency.**
   - Small functions and explicit context beat inheritance and classes.
   - Frequently changing elements (text, selectors, wait logic) are better managed in **one place (POM/utils)**.
   - **Always reassign currentPage** on page transitions.
   - Avoid over-abstraction; choose **small functions with explicit arguments**.

8. **Write readable tests.**
   - Use Given-When-Then structure with descriptive titles.
   - Test body should have mostly **business sentences**; button/selector/wait logic is POM's responsibility.
   - Write code like documentation. Add JSDoc with usage and cautions to all functions.

---

## 7. Note to Agents Reading This Document

1. Treat human-written scenarios in `e2e/specs/*.todo.md` as **source of truth**.
2. Follow Playwright Test Agents flow (planner → generator → healer), but always reference rules defined in this document at each step.
3. **Modify only test code, not app code.**
4. When something is ambiguous:
   - (If conversation is possible) Ask the user.
   - Otherwise, leave a `// TODO:` comment at test file top and write with most conservative assumptions.

This guide aims to create a test environment where, given only a TODO document, you can **run the full loop** through Planner / Generator / Healer / MCP.

---

## References

- [Playwright Best Practices](https://playwright.dev/docs/best-practices)
- [Toss Income Tax Refund Service: E2E Automation Journey](https://toss.tech/article/income-qa-e2e-automation) (Suho Jung, December 2, 2025)
  - Functional Page Object Model (POM) approach
  - Robust Click Strategy
  - Writing readable tests
  - Page transition detection
