---
description: E2E 테스트 – Playwright Test Agents (planner/generator/healer) + TODO 시나리오 문서 기반
globs:
  - 'e2e/**/*.{ts,tsx}'
  - 'tests/**/*.{ts,tsx}'
  - 'specs/**/*.md'
alwaysApply: true
---

# E2E 테스트 규칙

Next.js(App Router) + Playwright Test + Playwright Test Agents를 사용하는 E2E 테스트를 작성할 때 다음 규칙을 따릅니다:

## 1. 기본 원칙

- 사람이 작성한 **TODO 시나리오 문서**(`e2e/specs/*.todo.md`)를 **진실의 근원(source of truth)**으로 삼습니다.
- Playwright Test Agents의 표준 흐름(planner → generator → healer)을 따릅니다.
- 테스트는 항상 **사용자 관점(User journey)**을 우선합니다. 구현 디테일(내부 함수, DB 구조 등)에 불필요하게 의존하지 않습니다.
- **앱 코드 대신 테스트 코드에만 손을 댑니다.**

## 2. Planner 에이전트 규칙

- 입력:

  - 자연어 요청
  - 필수: seed test 파일 (`tests/seed.spec.ts`)
  - 선택: 관련 TODO 문서(`e2e/specs/*.todo.md`), PRD/디자인 문서

- 동작:

  1. seed test를 실행하여 앱을 실행하고 브라우저를 실제로 탐색해 DOM 구조를 이해합니다.
  2. TODO 문서의 시나리오를 기준으로 단계(steps)와 기대 결과(expected results)를 명시적으로 나눈 test plan을 만듭니다.
  3. 출력 위치: `specs/{feature-name}.md` (Markdown test plan)

- 주의사항:
  - planner는 **테스트 코드를 직접 생성하지 않습니다.**
  - 앱 구조를 모른다고 가정하고 locator를 박지 말고, "무엇을 검증해야 하는지"만 Markdown에 표현합니다.
  - TODO 문서에 없는 새로운 시나리오를 추가할 경우 섹션에 `Origin: planner-suggested` 같은 메모를 남깁니다.

## 3. Generator 에이전트 규칙

- 입력: `specs/*.md` (planner가 만든 Markdown plan), seed test, `playwright.config.ts`
- 출력: `e2e/tests/**.spec.ts` (Playwright TypeScript 테스트 코드)

### 코드 작성 규칙

- 기본 구조:

  - 파일명은 **기능 + 시나리오** 조합 (예: `post-like-guest.spec.ts`)
  - 테스트 이름은 TODO 문서의 시나리오 설명을 거의 그대로 사용하되, 약간 더 명확하게 다듬습니다.

- Next.js & 네비게이션:

  - 라우트 주소는 **절대 하드코딩하지 않습니다**. 반드시 constants 파일에서 가져옵니다:

    ```ts
    import { ROUTES } from '@/constants/routes';

    if (!ROUTES.POSTS) {
      throw new Error(
        'ROUTES.POSTS가 constants에 정의되어 있지 않습니다. constants 파일을 확인하세요.'
      );
    }
    await page.goto(ROUTES.POSTS);
    ```

  - 라우트 주소가 constants에 없으면 테스트를 실행하지 않고 사용자에게 알립니다.
  - `playwright.config.ts`의 `use.baseURL`을 최대한 사용합니다.
  - 페이지 전환 후:
    - `await page.waitForLoadState('networkidle')` **또는**
    - 특정 주요 요소 visibility assertion (`await expect(...).toBeVisible()`)로 안정화 후 나머지 검증을 진행합니다.
  - `waitForTimeout` 사용은 **금지** (flaky 원인).

- 스크린샷 / 비디오 / Trace:

  - `playwright.config.ts`에서 실패 시 자동 캡처 설정:
    - `screenshot: "only-on-failure"`
    - `video: "retain-on-failure"`
    - `trace: "retain-on-failure"`
  - 디버깅 시 `npx playwright test --trace on` → `npx playwright show-report`

- Locator 전략 (우선순위):

  1. `page.getByTestId(...)` — 최우선. 가장 안정적이고 명시적.
  2. `page.getByRole(...)` — 접근성 검증 겸용
  3. `page.getByLabel(...)` — 폼 컨트롤용
  4. `page.getByText(...)` — 비상호작용 요소용
  5. CSS/XPath locator (`page.locator`) — 최후 수단

- Assertions:

  - web-first assertion(`await expect(...)`)만 사용합니다.
  - `.isVisible()` 호출 후 동기 `expect` 쓰는 패턴은 금지.
  - 여러 검증이 필요한 경우:
    - 주요 결과는 hard assertion
    - 덜 중요한 UI 메시지 등은 `expect.soft` 사용 가능.

- 로그인 / 권한:
  - 이미 존재하는 fixture/helper를 **최우선 재사용**합니다 (예: `auth.fixtures.ts`).
  - 없다면 새로 작성하되, 재사용을 위한 이름으로 만듭니다.

## 4. Healer 에이전트 규칙

- 역할: 실패한 Playwright 테스트를 디버깅하고, 가능한 경우 자동으로 수정합니다.

- 수정 대상:

  - 바뀐 locator (레이블 이름 변경, 버튼 텍스트 변경 등)
  - 타이밍 이슈 (불필요한 `waitForTimeout`, 잘못된 load 조건 등)
  - 경미한 데이터 변경 (텍스트 문구 변경, 카운트 값 정합성 등)

- 동작 순서:

  1. 실패한 테스트 식별 (`mcp__playwright-test__test_list` / `test_run` 등)
  2. 재실행 & UI 조사 (`browser_snapshot`, `browser_console_messages`, `browser_network_requests` 등 활용)
  3. 패치 제안 & 적용 (locator 업데이트, 불필요한 wait 제거, assertion 문구 수정 등 - **테스트 코드만 수정**)
  4. 재실행 후 결과 보고

- 금지사항:
  - 앱의 실제 구현 코드(Next.js 페이지/컴포넌트/백엔드 코드)를 수정하지 않습니다.
  - 의미를 흐리는 "느슨한 assertion"(ex. `toBeTruthy`)로 바꾸어 억지로 통과시키지 않습니다.
  - TODO 문서/PRD의 요구사항을 무시하고, 임의의 behavior로 정의를 바꾸지 않습니다.
  - 기능 자체가 깨진 경우, 테스트를 무리하게 "통과"시키지 말고 주석/메모와 함께 실패 상태로 남기거나 `test.skip`으로 전환합니다.

## 5. Functional Page Object Model (POM)

> **참고**: [토스인컴의 E2E 자동화 여정](https://toss.tech/article/income-qa-e2e-automation)에서 영감을 받은 Functional POM 접근법

- **클래스 대신 함수형 POM 사용**: 상태를 가지는 클래스 대신, 무상태(Stateless) 함수로 페이지 동작을 설계합니다.

  - 입력: `page` (그리고 필요 시 `context`)
  - 출력: `page`
  - 예: `export async function gotoPostListPage(page: Page): Promise<Page>`

- **사용자 시나리오 기준으로 파일 나누기**: 화면이 아니라 사용자 시나리오를 기준으로 경계를 나눕니다.

  - 예: `post-list.page.ts`, `post-write.page.ts`, `post-detail.page.ts`

- **네이밍 컨벤션**: `goto`, `click`, `enter`, `answer`, `add`/`skip`, `verify`/`check`, `waitFor`, `complete` 접두사 사용

- **Robust Click Strategy**: 클릭 실패에 내성을 넣기 위해 4단계 폴백 (Enter 키 → 기본 클릭 → Force 클릭 → JS 직접 실행)

- **페이지 전환 자동 감지**: 새 창/리다이렉트 후에는 `currentPage = await getLatestValidPage(context)`로 최신 페이지를 가져옵니다.

- **읽히는 테스트 작성**: Given-When-Then 구조, 서술형 제목, 비즈니스 문장 중심, POM에 구현 세부사항 캡슐화

## 6. 공통 테스트 철학

1. **사용자 눈에 보이는 행동만 검증합니다.**

   - DOM 깊은 구조, 내부 state, API 형태 등 구현 세부사항에 과도하게 의존하지 않습니다.

2. **테스트는 서로 독립적이어야 합니다 (Test Isolation).**

   - 각 테스트는 필요한 상태(로그인, seed 데이터)를 스스로 준비합니다.
   - 테스트 격리는 **재현성을 높이고, 디버깅을 쉽게 하며, 연쇄 실패를 방지**합니다.
   - `test.beforeEach()` 훅으로 반복 작업을 자동화하거나, setup project를 활용합니다.

3. **약간의 중복은 허용하되, 복잡해지면 helper/fixture로 추상화합니다.**

4. **테스트 명과 파일 명을 보면 "무엇을 검증하는지" 바로 떠오르게 만듭니다.**

5. **플레이크 방지를 최우선으로 고려합니다.**

   - 타이밍 이슈는 web-first assertion/locator 전략으로 해결합니다.
   - Robust Click Strategy를 사용하여 클릭 실패에 내성을 만듭니다.

6. **에이전트는 테스트 코드만 자동화합니다.**

   - 비즈니스 로직, 도메인 규칙은 사람이 정의한 TODO 문서/PRD를 항상 우선합니다.

7. **Functional POM 원칙**:
   - 복잡함을 이기는 방법은 단순화와 일관성입니다.
   - 상속과 클래스보다 작은 함수와 명시적 컨텍스트가 강합니다.
   - 자주 변하는 요소는 한 곳(POM/유틸)에 모아 관리합니다.
   - 페이지 전환 시 반드시 currentPage를 새로 할당합니다.
   - 과한 추상화를 피하고 작은 함수와 명시적 인자로 명료함을 택합니다.

## 7. 모호한 부분 처리

- (대화 가능한 환경이면) 사용자에게 질문합니다.
- 그렇지 않다면 테스트 파일 상단에 `// TODO:` 주석을 남기고, 가장 보수적인 가정으로 작성합니다.
