---
description: 프론트엔드 코드 품질 규칙 – 가독성, 예측 가능성, 응집도, 결합도 기반 변경하기 쉬운 코드 작성
globs:
  - "src/**/*.{ts,tsx,js,jsx}"
alwaysApply: true
---

# 프론트엔드 코드 품질 규칙

프론트엔드 코드(React/TypeScript)를 편집하거나 생성할 때, 다음 네 가지 원칙을 기반으로 한 규칙을 따릅니다:

## 1. 가독성 – 맥락을 작게 유지하기

- 컴포넌트나 함수에 함께 실행되지 않는 분기(예: 다른 역할/모드/상태)가 포함되어 있다면,
  별도의 컴포넌트/함수로 분리하고 작은 디스패처를 사용합니다:

  - 권장:

    - `return isViewer ? <ViewerSubmitButton /> : <AdminSubmitButton />;`
    - 각 자식은 **하나의 경우만** 처리합니다.

- 로그인 확인이나 리다이렉트 같은 횡단 관심사를 숨기기 위해 래퍼 컴포넌트나 HOC(예: `AuthGuard`, `withAuthGuard`)를 사용합니다.
  페이지 컴포넌트는 주로 "이 페이지가 무엇을 하는지"만 보여야 합니다.

- 여러 쿼리 파라미터, 상태, API 호출을 섞는 "갓 훅" 같은 `usePageState`는 **만들지 않습니다**.
  대신 책임 하나당 하나의 훅을 만듭니다.

- 복잡한 조건의 경우:

  - 중첩된 논리 연산자를 체이닝하는 대신, 불리언 플래그(`isSameCategory`, `isPriceInRange`, …)나 헬퍼 함수를 추출합니다.

- 관련 로직 근처에 배치된 명명된 상수로 매직 넘버를 대체합니다:

  - `const LIKE_ANIMATION_DELAY_MS = 300;`
  - 원시 숫자 대신 상수를 사용합니다.

- 여러 경우가 있을 때 중첩된 삼항 연산자보다 간단한 `if` 체인을 선호합니다:

  - 권장:

    ```ts
    if (A && B) return "BOTH";
    if (A) return "A";
    if (B) return "B";
    return "NONE";
    ```

## 2. 예측 가능성 – 일관된 이름과 반환 타입

- 커스텀 래퍼에 라이브러리 이름을 재사용하지 않습니다. `http`를 래핑하는 경우:

  - `httpService`, `authenticatedHttp` 등 다른 이름을 사용합니다.
  - 동작을 드러내는 메서드 이름을 사용합니다. 예: `getWithAuth`.

- React Query 훅의 경우:

  - 항상 전체 쿼리 객체(`UseQueryResult`)를 반환합니다. 어떤 훅은 `data`를, 어떤 훅은 `query`를 반환하지 않도록 합니다.

- 유효성 검사 함수의 경우:

  - 통일된 반환 타입을 사용합니다:

    ```ts
    type ValidationResult = { ok: true } | { ok: false; reason: string };
    ```

  - 모든 `checkIs*Valid` 함수가 이 형태를 반환하도록 합니다.

- 숨은 부작용을 피합니다:

  - 이름/시그니처로 드러나지 않는 함수 내부에 로깅, 추적, 외부 상태 변경을 넣지 **않습니다**.
  - 예: `fetchBalance()`는 잔액만 가져와서 반환해야 합니다.
  - 로깅, 분석, 후속 작업은 호출 지점에 둡니다.

## 3. 응집도 – 함께 변경되는 것들을 가까이 두기

- 타입별이 아닌 **도메인**별로 폴더를 구성합니다:

  - 한 도메인 내에서만 사용되는 코드는 해당 도메인 폴더 아래에 둡니다
    (`domains/User`, `domains/Payment`, …).
  - 진짜로 도메인 간 공유되는 코드는 최상위 `components`, `hooks`, `utils` 등에 둡니다.

- 다음과 같은 깊은 도메인 간 import를 보면:

  - `import { useFoo } from "../../../Domain2/hooks/useFoo";`

  코드 스멜로 보고 다음을 고려합니다:

  - 공유 로직을 새로운 공유 도메인으로 이동하거나,
  - 명확한 이름의 공유 폴더로 끌어올립니다.

- 폼의 경우:

  - 먼저 **필드 단위** 또는 **폼 단위** 응집 중 어느 것이 더 적합한지 결정합니다.

  - 필드 단위 검증을 사용하는 경우:

    - 필드가 복잡하고 독립적인 규칙이나 비동기 검증을 가지고 있고,
    - 같은 필드 + 검증이 여러 폼에서 재사용될 때.

  - 폼 단위 스키마(예: Zod)를 사용하는 경우:
    - 폼이 하나의 비즈니스 행위를 나타내고,
    - 많은 필드가 서로 의존할 때(위저드, 합계 계산, 필드 간 검사).

## 4. 결합도 – 변경의 영향을 제어하기

- 훅의 책임을 작게 유지합니다:

  - "이 페이지의 모든 것을 관리하는" 훅을 피합니다.
  - 하나의 큰 `usePageState`보다 `useCardIdQueryParam`, `useDateRangeQueryParam` 등을 선호합니다.

- DRY에 주의합니다:

  - 두 코드가 오늘 비슷해 보인다고 해서 공통 훅/컴포넌트를 추출하지 **않습니다**.
  - 다음 조건을 만족할 때만 추출합니다:

    - 호출자 간 동작이 동일하고,
    - 향후 분기 가능성이 낮으며,
    - 추상화가 테스트와 변경을 더 쉽게 만들 때.

  - 각 페이지가 분기될 가능성이 크다면(다른 로깅, 다른 텍스트, 다른 흐름),
    강제된 추상화보다 **로컬 중복을 선호**합니다.

- Props Drilling을 다음 순서로 줄입니다:

  1. 먼저 불필요한 중간 추상화를 제거하고 책임별로 컴포넌트를 분리합니다
     (예: 모호한 `ItemEditBody` 대신 `ItemEditSearch`, `ItemEditList`).
  2. 그 다음 조합(Composition)을 사용합니다: 부모에서 `children`으로 전달하여
     실제로 데이터를 사용하는 컴포넌트만 받도록 합니다.
  3. 같은 데이터를 여러 단계에서 깊이 소비해야 하는 경우에만,
     해당 도메인 전용 Context를 도입합니다.

- 전역 상태 라이브러리는 Props Drilling 해결책이 아니라
  **페이지 간 관심사에 대한 최후의 수단**으로 사용합니다.

## 5. 트레이드오프

- 선택해야 할 때는 다음 순서로 원칙을 적용합니다:

  1. 영리한 추상화보다 가독성을 선호합니다.
  2. 예측 가능성을 유지합니다(일관된 네이밍 & 반환 타입).
  3. 응집도와 결합도를 도메인의 실제 변경 경계에 맞게 조정합니다.

- 리팩토링할 때는 주석이나 커밋 메시지에서 **어떤 원칙을 최적화했는지** 설명합니다
  (예: "가독성 향상을 위해 역할별로 컴포넌트 분리", "결합도 감소를 위해 로직 중복 허용").
