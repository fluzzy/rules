---
description: 프론트엔드 접근성(a11y) 규칙 – 시맨틱 태그, ARIA 속성, 키보드 탐색, UI 컴포넌트별 패턴
globs:
  - "src/**/*.{ts,tsx,js,jsx}"
alwaysApply: true
---

# 접근성 규칙

프론트엔드 코드(React/TypeScript)를 편집하거나 생성할 때, 다음 접근성 원칙을 따릅니다:

## 1. 기본 원칙 – 역할, 레이블, 상태

- 가능한 한 **시맨틱 태그**를 먼저 사용합니다:

  - `<button>`, `<a>`, `<input>`, `<form>`, `<fieldset>`, `<legend>`, `<dialog>`, `<details>`, `<summary>` 등.

- 시맨틱 태그로 표현이 안 되면 `role`로 명시합니다.

- 모든 **인터랙티브 요소**는 항상 이름을 가져야 합니다:

  - 우선순위: `aria-labelledby` → `aria-label` → `<label>`/요소 텍스트.
  - 아이콘만 있는 버튼/스위치/토글은 `aria-label` 또는 `aria-labelledby` 필수.

- 상태는 **HTML 기본 속성**과 **ARIA 상태 속성**을 항상 동기화합니다:

  - `checked` / `aria-checked`
  - `selected` / `aria-selected`
  - `open` / `aria-expanded`
  - `disabled` / `aria-disabled`

- **커스텀 인터랙티브 요소**를 만들면:

  - `tabIndex={0}` 부여
  - `role` 설정
  - `onKeyDown`에서 Enter / Space 처리

- 색/아이콘/이미지로만 정보가 전달되면 안 됩니다. 항상 **텍스트 또는 ARIA 레이블**로 보완합니다.

- 의미 없는 장식 이미지는 `alt=""`로 처리합니다.

## 2. 라이브 리전(Live Region)

동적으로 변경되는 콘텐츠를 스크린 리더에 알려주기 위해 라이브 리전을 사용합니다:

- **`aria-live`**: 콘텐츠 변경 시 스크린 리더가 읽어줌

  - `aria-live="polite"`: 현재 읽고 있는 내용이 끝난 후 알림 (일반적인 업데이트)
  - `aria-live="assertive"`: 즉시 알림 (긴급한 오류, 중요 알림)

- **`role="alert"`**: `aria-live="assertive"` + `aria-atomic="true"`와 동일. 오류 메시지, 긴급 알림에 사용.

- **`role="status"`**: `aria-live="polite"` + `aria-atomic="true"`와 동일. 상태 업데이트, 성공 메시지에 사용.

- **`aria-busy`**: 콘텐츠가 로딩 중임을 알림. `true`일 때 스크린 리더가 변경 알림을 보류.

- **`aria-atomic`**: `true`이면 변경된 부분만이 아닌 전체 영역을 읽음.

예시:

```tsx
// 폼 제출 결과 알림
<div role="status" aria-live="polite">
  {submitSuccess && "저장되었습니다."}
</div>

// 오류 메시지
<div role="alert">
  {errorMessage}
</div>

// 로딩 상태
<div aria-busy={isLoading} aria-live="polite">
  {isLoading ? "로딩 중..." : content}
</div>
```

## 3. UI 컴포넌트별 규칙

### 3-1. 탭(Tab)

- 구조:

  - 탭 리스트: `role="tablist"` + `aria-label` 또는 `aria-labelledby`
  - 탭 버튼: `role="tab"` + `aria-selected={true|false}`
  - 탭 패널: `role="tabpanel"` + `id` 필수
  - 탭 버튼에서 `aria-controls="<tabpanel-id>"`
  - 탭 패널에서 `aria-labelledby="<tab-id>"`

- 활성 패널만 보이게 하고, 나머지는 `hidden` 또는 `aria-hidden`/CSS로 숨깁니다.
- `aria-selected` 값과 패널 표시 여부를 항상 동기화합니다.
- 방향키(좌/우)로 탭 이동 가능하게 구현합니다.

### 3-2. 아코디언(Accordion)

- 가능하면 `<details>` + `<summary>` 사용을 우선합니다.
- 커스텀 구현 시:

  - 헤더: `<button>` + `aria-expanded={isOpen}` + `aria-controls="<panel-id>"`
  - 패널: `id="<panel-id>"` + `role="region"` + `aria-labelledby="<button-id>"` + `hidden={!isOpen}`

- `aria-expanded` 값과 패널 표시 여부를 항상 동기화합니다.

### 3-3. 모달(Modal/Dialog)

- 가능하면 `<dialog>` 사용을 우선합니다:

  - 트리거 버튼: `aria-haspopup="dialog"`
  - `dialog.showModal()`로 열기, `dialog.close()`로 닫기
  - `aria-labelledby` 또는 `aria-label`로 제목 제공

- 커스텀 모달 시:

  - 컨테이너: `role="dialog"` + `aria-modal="true"` + `aria-labelledby` 또는 `aria-label`
  - 모달 열릴 때: 내부 첫 포커스 가능한 요소로 이동
  - 모달 닫힐 때: 열었던 트리거로 포커스 복귀
  - ESC 핸들링: `keydown` 이벤트에서 `e.key === "Escape"`이면 닫기
  - 배경 콘텐츠: 모달 열려 있을 때 메인 영역에 `inert` 부여
  - 포커스 트랩: Tab/Shift+Tab으로 포커스가 모달 안에서만 순환

### 3-4. 라디오 버튼(Radio)

- 기본 구조 (권장):

  - 컨테이너: `<fieldset>` + 제목: `<legend>`
  - 각 옵션: `<input type="radio" name="...">` + `<label htmlFor="...">`

- `<fieldset>`을 쓸 수 없으면:

  - 컨테이너: `role="radiogroup"` + `aria-labelledby="<heading-id>"`

- 같은 그룹은 `name` 동일하게 설정합니다.
- 각 옵션은 항상 레이블과 연결합니다 (`id` + `htmlFor`).

- 커스텀 라디오 (input 미사용):

  - 각 옵션: `role="radio"` + `aria-checked={true|false}` + `tabIndex={0}` + Space 키 처리
  - 그룹: `role="radiogroup"` + `aria-labelledby`

### 3-5. 체크박스(Checkbox)

- 그룹이 있는 경우:

  - 컨테이너: `<fieldset>` + 제목: `<legend>`
  - 각 항목: `<input type="checkbox" id="..." />` + `<label htmlFor="...">`

- 커스텀 체크박스:

  - `role="checkbox"` + `aria-checked={true|false}` + `tabIndex={0}` + Space 키 처리

### 3-6. 스위치(Switch)

- HTML 기반: `<input type="checkbox" role="switch" checked={isOn} />` + 레이블
- 커스텀 스위치:

  - `role="switch"` + `aria-checked={isOn}` + `tabIndex={0}` + Space 키 처리
  - 레이블 필수 ("무엇을 켜고 끄는지" 설명)

## 4. 실전 패턴

- **버튼 안에 버튼/링크 넣지 않기**:

  - 금지: `<button>` 안에 `<button>`, `<a>` 안에 `<button>`, `<button>` 안에 `<a>`
  - 해결: 폴리모픽 버튼 패턴 (`<Button as="a" href="/...">`) 또는 카드 전체 클릭 + 내부 개별 버튼 패턴

- **테이블 행을 직접 클릭 가능하게 만들지 않기**:

  - 금지: `<tr onClick={...}>`
  - 해결: 행 안에 실제 `<a>` 링크를 넣고 CSS로 영역 확장

- **인터랙티브 요소에 이름 붙이기**:

  - 모든 입력/버튼/선택 요소는 항상 이름을 가집니다.
  - 입력 필드: 우선 `<label for="id">` + `<input id="id">`, 없으면 `aria-label` 또는 `aria-labelledby`
  - 버튼/아이콘: 텍스트 버튼이면 내부 텍스트가 레이블, 아이콘 버튼이면 `aria-label` 필수
  - placeholder는 레이블 대체용 X, 힌트 용도로만 사용

- **같은 이름의 버튼이 여러 개 있을 때**:

  - 각 항목에 "맥락 텍스트"를 만들고 버튼과 연결
  - 또는 버튼에 `aria-label="맥락 텍스트 + 버튼명"` 형식으로 구체화

- **버튼의 역할과 동작을 일치시키기**:

  - 금지: 단순 `<div onClick>`에 `cursor: pointer`만 주고 버튼처럼 쓰는 것
  - 기본: 가능하면 무조건 `<button>` 사용
  - 꼭 `<div>` 등으로 해야 한다면: `role="button"` + `tabIndex={0}` + Enter/Space 처리

- **입력 요소는 항상 `<form>`으로 감싸기**:

  - 관련 입력 그룹은 `<form>` 안에 넣습니다.
  - submit 버튼은 `<button type="submit">`
  - 단순 클릭용 버튼은 반드시 `type="button"` 명시
  - 폼 밖에 있는 submit 버튼은 `form="form-id"` 속성으로 연결

- **이미지/아이콘 대체 텍스트(alt)**:

  - 원칙: "이 이미지가 사용자에게 전달하려는 정보 또는 기능이 무엇인가?"를 기준으로 작성
  - 필수: 이미지가 링크/버튼의 유일한 내용일 때, 핵심 정보를 담은 경우
  - `alt=""`: 장식용 이미지, 주변 텍스트가 이미 설명하는 경우, 텍스트와 함께 있는 아이콘
  - 불필요한 단어(`아이콘`, `버튼`) 제거, 맥락 기반으로 작성

## 5. eslint-plugin-jsx-a11y

- 필수 규칙:

  - `alt-text`: `<img>`는 항상 `alt`가 있어야 함 (장식 이미지는 `alt=""`)
  - `control-has-associated-label`: 모든 컨트롤에 연관 레이블 필수
  - `no-noninteractive-element-interactions`: 비상호작용 요소에 `onClick` 사용 시 경고
  - `no-noninteractive-element-to-interactive-role`: 의미 있는 컨테이너에 상호작용 역할 부여 금지
  - `no-noninteractive-tabindex`: 비상호작용 요소에 `tabIndex` 금지
  - `tabindex-no-positive`: `tabIndex > 0` 금지 (허용 값: `0` 또는 `-1`만)

- 디자인 시스템/폴리모픽 컴포넌트와 연동:

  - `settings.jsx-a11y.components`로 커스텀 컴포넌트 매핑
  - `polymorphicPropName: "as"`로 폴리모픽 prop 지원
  - `labelAttributes`로 커스텀 레이블 prop 지원

## 6. 새 컴포넌트 작성 시 체크리스트

컴포넌트를 만들 때 다음을 반드시 확인합니다:

1. **역할(Role)**: 시맨틱 태그를 사용했는가? 필요시 `role`을 명시했는가?
2. **레이블(Label)**: 모든 인터랙티브 요소에 이름이 있는가?
3. **상태(State)**: 상태 속성이 HTML/ARIA와 동기화되어 있는가?
4. **키보드 탐색**: Tab, Enter, Space, 방향키로 조작 가능한가?
5. **시각 의존성**: 색/아이콘만으로 정보를 전달하지 않았는가?
6. **eslint-plugin-jsx-a11y**: 설정된 규칙을 위반하지 않았는가?
